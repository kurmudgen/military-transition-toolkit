#!/bin/bash

###############################################################################
# PENETRATION TEST - API ENDPOINT SECURITY TESTING
# Military Transition Application
#
# USAGE: ./run-api-tests.sh <VERCEL_URL> <JWT_TOKEN>
# EXAMPLE: ./run-api-tests.sh https://military-transition.vercel.app eyJhbG...
#
# REQUIREMENTS:
#   - curl installed
#   - jq installed (for JSON parsing)
#   - Valid JWT token from authenticated user
#
# OUTPUT: results/api-test-results.txt with detailed findings
###############################################################################

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check arguments
if [ "$#" -ne 2 ]; then
    echo -e "${RED}ERROR: Missing required arguments${NC}"
    echo "USAGE: $0 <VERCEL_URL> <JWT_TOKEN>"
    echo "EXAMPLE: $0 https://military-transition.vercel.app eyJhbG..."
    exit 1
fi

APP_URL="$1"
JWT_TOKEN="$2"

# Create results directory
mkdir -p results
RESULTS_FILE="results/api-test-results-$(date +%Y%m%d-%H%M%S).txt"

echo "========================================" | tee -a "$RESULTS_FILE"
echo "  API PENETRATION TEST - STARTED" | tee -a "$RESULTS_FILE"
echo "========================================" | tee -a "$RESULTS_FILE"
echo "Target: $APP_URL" | tee -a "$RESULTS_FILE"
echo "Date: $(date)" | tee -a "$RESULTS_FILE"
echo "JWT: ${JWT_TOKEN:0:20}..." | tee -a "$RESULTS_FILE"
echo "" | tee -a "$RESULTS_FILE"

###############################################################################
# HELPER FUNCTIONS
###############################################################################

test_passed() {
    echo -e "${GREEN}✅ PASS${NC}: $1" | tee -a "$RESULTS_FILE"
}

test_failed() {
    echo -e "${RED}❌ FAIL${NC}: $1" | tee -a "$RESULTS_FILE"
}

test_warning() {
    echo -e "${YELLOW}⚠️  WARNING${NC}: $1" | tee -a "$RESULTS_FILE"
}

test_info() {
    echo -e "${BLUE}ℹ️  INFO${NC}: $1" | tee -a "$RESULTS_FILE"
}

run_test() {
    local test_name="$1"
    echo "" | tee -a "$RESULTS_FILE"
    echo "========================================" | tee -a "$RESULTS_FILE"
    echo "TEST: $test_name" | tee -a "$RESULTS_FILE"
    echo "========================================" | tee -a "$RESULTS_FILE"
}

###############################################################################
# TEST 1: SECURITY HEADERS
###############################################################################

run_test "Security Headers Verification"

echo "Fetching security headers..." | tee -a "$RESULTS_FILE"
HEADERS=$(curl -sI "$APP_URL" 2>&1)

echo "$HEADERS" >> "$RESULTS_FILE"

# Check each required header
if echo "$HEADERS" | grep -qi "Content-Security-Policy"; then
    test_passed "Content-Security-Policy header present"
else
    test_failed "Content-Security-Policy header MISSING"
fi

if echo "$HEADERS" | grep -qi "X-Frame-Options.*DENY"; then
    test_passed "X-Frame-Options: DENY header present"
else
    test_failed "X-Frame-Options header MISSING or not set to DENY"
fi

if echo "$HEADERS" | grep -qi "X-Content-Type-Options.*nosniff"; then
    test_passed "X-Content-Type-Options: nosniff header present"
else
    test_failed "X-Content-Type-Options header MISSING"
fi

if echo "$HEADERS" | grep -qi "Strict-Transport-Security"; then
    test_passed "HSTS (Strict-Transport-Security) header present"
else
    test_failed "HSTS header MISSING - HTTPS may not be enforced"
fi

if echo "$HEADERS" | grep -qi "Referrer-Policy"; then
    test_passed "Referrer-Policy header present"
else
    test_warning "Referrer-Policy header MISSING"
fi

###############################################################################
# TEST 2: HTTPS ENFORCEMENT
###############################################################################

run_test "HTTPS Enforcement"

# Try HTTP (should redirect to HTTPS)
HTTP_RESPONSE=$(curl -sI "http://$(echo $APP_URL | sed 's|https://||')" 2>&1)

if echo "$HTTP_RESPONSE" | grep -qi "301\|302"; then
    test_passed "HTTP redirects to HTTPS (301/302 found)"
elif echo "$HTTP_RESPONSE" | grep -qi "https"; then
    test_passed "HTTPS enforced"
else
    test_failed "HTTP to HTTPS redirect NOT working"
fi

###############################################################################
# TEST 3: CSRF TOKEN ENDPOINT
###############################################################################

run_test "CSRF Token Endpoint"

CSRF_RESPONSE=$(curl -s "$APP_URL/api/csrf-token" \
    -H "Authorization: Bearer $JWT_TOKEN" \
    2>&1)

echo "CSRF Response: $CSRF_RESPONSE" >> "$RESULTS_FILE"

if echo "$CSRF_RESPONSE" | jq -e '.csrfToken' > /dev/null 2>&1; then
    CSRF_TOKEN=$(echo "$CSRF_RESPONSE" | jq -r '.csrfToken')
    test_passed "CSRF token endpoint returns valid token: ${CSRF_TOKEN:0:20}..."

    # Check if token looks like a valid signature
    if [ ${#CSRF_TOKEN} -gt 32 ]; then
        test_passed "CSRF token length appropriate (${#CSRF_TOKEN} chars)"
    else
        test_warning "CSRF token seems short (${#CSRF_TOKEN} chars) - may be weak"
    fi
else
    test_failed "CSRF token endpoint not working or invalid response"
fi

###############################################################################
# TEST 4: AUTHENTICATION - MISSING TOKEN
###############################################################################

run_test "Authentication - Missing JWT Token"

UNAUTH_RESPONSE=$(curl -s -w "\n%{http_code}" "$APP_URL/api/stripe/create-portal-session" \
    -H "Content-Type: application/json" \
    2>&1)

HTTP_CODE=$(echo "$UNAUTH_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$UNAUTH_RESPONSE" | head -n-1)

echo "HTTP Code: $HTTP_CODE" >> "$RESULTS_FILE"
echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"

if [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "403" ]; then
    test_passed "Unauthorized request correctly rejected ($HTTP_CODE)"
else
    test_failed "Unauthorized request NOT rejected (got $HTTP_CODE instead of 401/403)"
fi

###############################################################################
# TEST 5: AUTHENTICATION - INVALID TOKEN
###############################################################################

run_test "Authentication - Invalid JWT Token"

INVALID_RESPONSE=$(curl -s -w "\n%{http_code}" "$APP_URL/api/stripe/create-portal-session" \
    -H "Authorization: Bearer invalid_token_12345" \
    -H "Content-Type: application/json" \
    2>&1)

HTTP_CODE=$(echo "$INVALID_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$INVALID_RESPONSE" | head -n-1)

echo "HTTP Code: $HTTP_CODE" >> "$RESULTS_FILE"
echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"

if [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "403" ]; then
    test_passed "Invalid token correctly rejected ($HTTP_CODE)"
else
    test_failed "Invalid token NOT rejected (got $HTTP_CODE)"
fi

###############################################################################
# TEST 6: PRICE MANIPULATION - INVALID PRICE ID
###############################################################################

run_test "Price Manipulation - Invalid Price ID"

FAKE_PRICE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$APP_URL/api/stripe/create-checkout-session" \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"priceId":"price_FAKE_FREE_TIER"}' \
    2>&1)

HTTP_CODE=$(echo "$FAKE_PRICE_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$FAKE_PRICE_RESPONSE" | head -n-1)

echo "HTTP Code: $HTTP_CODE" >> "$RESULTS_FILE"
echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"

if [ "$HTTP_CODE" = "400" ] || echo "$RESPONSE_BODY" | grep -qi "invalid.*price"; then
    test_passed "Fake price ID correctly rejected"
else
    test_failed "Fake price ID NOT rejected - CRITICAL VULNERABILITY"
fi

###############################################################################
# TEST 7: CSRF PROTECTION - MISSING CSRF TOKEN
###############################################################################

run_test "CSRF Protection - Request Without CSRF Token"

# Try account deletion without CSRF token (if endpoint exists)
NO_CSRF_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$APP_URL/api/delete-account" \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"confirm":false}' \
    2>&1)

HTTP_CODE=$(echo "$NO_CSRF_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$NO_CSRF_RESPONSE" | head -n-1)

echo "HTTP Code: $HTTP_CODE" >> "$RESULTS_FILE"
echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"

if [ "$HTTP_CODE" = "403" ] || echo "$RESPONSE_BODY" | grep -qi "csrf"; then
    test_passed "Request without CSRF token correctly rejected"
elif [ "$HTTP_CODE" = "404" ]; then
    test_info "Delete account endpoint not found (404) - cannot test CSRF"
else
    test_warning "CSRF protection unclear (HTTP $HTTP_CODE) - may be vulnerable"
fi

###############################################################################
# TEST 8: PROMO STATUS ENDPOINT (SERVER-SIDE VALIDATION)
###############################################################################

run_test "Promo Status - Server-Side Validation"

PROMO_RESPONSE=$(curl -s "$APP_URL/api/promo-status" 2>&1)

echo "Promo Response: $PROMO_RESPONSE" >> "$RESULTS_FILE"

if echo "$PROMO_RESPONSE" | jq -e '.active' > /dev/null 2>&1; then
    PROMO_ACTIVE=$(echo "$PROMO_RESPONSE" | jq -r '.active')
    test_passed "Promo status endpoint returns valid response (active: $PROMO_ACTIVE)"
    test_info "Server-side promo validation implemented (PENTEST-003 fix verified)"
else
    test_failed "Promo status endpoint not working properly"
fi

###############################################################################
# TEST 9: RATE LIMITING - LOGIN ENDPOINT
###############################################################################

run_test "Rate Limiting - Rapid Requests Test"

test_info "Sending 15 rapid requests to test rate limiting..."

RATE_LIMIT_TRIGGERED=false
for i in {1..15}; do
    RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$APP_URL/api/csrf-token" \
        -H "Authorization: Bearer $JWT_TOKEN" \
        2>&1)

    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)

    if [ "$HTTP_CODE" = "429" ]; then
        test_passed "Rate limiting triggered after $i requests (HTTP 429)"
        RATE_LIMIT_TRIGGERED=true
        break
    fi

    sleep 0.1
done

if [ "$RATE_LIMIT_TRIGGERED" = false ]; then
    test_warning "Rate limiting NOT triggered after 15 requests - may be vulnerable to abuse"
    test_warning "NOTE: Rate limiting may have higher threshold or be disabled in test env"
fi

###############################################################################
# TEST 10: ERROR HANDLING - STACK TRACE LEAKAGE
###############################################################################

run_test "Error Handling - Stack Trace Leakage"

# Send malformed request to trigger error
ERROR_RESPONSE=$(curl -s -X POST "$APP_URL/api/stripe/create-checkout-session" \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Content-Type: application/json" \
    -d 'invalid json syntax' \
    2>&1)

echo "Error Response: $ERROR_RESPONSE" >> "$RESULTS_FILE"

if echo "$ERROR_RESPONSE" | grep -qi "stack\|\.js:\|Error:\s*at\|node_modules"; then
    test_failed "STACK TRACE LEAKED in error response - information disclosure vulnerability"
    echo "$ERROR_RESPONSE" >> "$RESULTS_FILE"
else
    test_passed "No stack trace in error response"
fi

if echo "$ERROR_RESPONSE" | grep -qi "supabase.*error\|database.*error\|pg_"; then
    test_failed "DATABASE ERROR details leaked - schema information disclosure"
else
    test_passed "No database error details in response"
fi

###############################################################################
# TEST 11: WEBHOOK ENDPOINT - SIGNATURE VALIDATION
###############################################################################

run_test "Webhook - Invalid Signature Rejection"

WEBHOOK_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$APP_URL/api/stripe/webhook" \
    -H "Content-Type: application/json" \
    -H "stripe-signature: fake_signature_12345" \
    -d '{"type":"checkout.session.completed","data":{}}' \
    2>&1)

HTTP_CODE=$(echo "$WEBHOOK_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$WEBHOOK_RESPONSE" | head -n-1)

echo "HTTP Code: $HTTP_CODE" >> "$RESULTS_FILE"
echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"

if [ "$HTTP_CODE" = "400" ] || echo "$RESPONSE_BODY" | grep -qi "signature"; then
    test_passed "Invalid webhook signature correctly rejected"
else
    test_failed "Invalid webhook signature NOT rejected - webhook vulnerable"
fi

###############################################################################
# TEST 12: SQL INJECTION ATTEMPT
###############################################################################

run_test "SQL Injection - Parameterized Query Verification"

# Note: This shouldn't work with Supabase, but test anyway
SQL_INJECTION_PAYLOAD='{"priceId":"price_123\"; DROP TABLE users; --"}'

SQL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$APP_URL/api/stripe/create-checkout-session" \
    -H "Authorization: Bearer $JWT_TOKEN" \
    -H "Content-Type: application/json" \
    -d "$SQL_INJECTION_PAYLOAD" \
    2>&1)

HTTP_CODE=$(echo "$SQL_RESPONSE" | tail -n1)
RESPONSE_BODY=$(echo "$SQL_RESPONSE" | head -n-1)

echo "HTTP Code: $HTTP_CODE" >> "$RESULTS_FILE"
echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"

# Should be rejected as invalid price, not cause SQL error
if echo "$RESPONSE_BODY" | grep -qi "syntax.*error\|sql.*error\|query.*failed"; then
    test_failed "SQL error message returned - possible SQL injection vulnerability"
else
    test_passed "SQL injection payload handled safely (no SQL error messages)"
fi

###############################################################################
# TEST 13: CORS CONFIGURATION
###############################################################################

run_test "CORS Configuration"

CORS_RESPONSE=$(curl -s -I "$APP_URL/api/csrf-token" \
    -H "Origin: https://evil-attacker.com" \
    2>&1)

echo "$CORS_RESPONSE" >> "$RESULTS_FILE"

if echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Origin: \*"; then
    test_failed "CORS allows ANY origin (*) - CSRF attacks possible"
elif echo "$CORS_RESPONSE" | grep -qi "Access-Control-Allow-Origin"; then
    ALLOWED_ORIGIN=$(echo "$CORS_RESPONSE" | grep -i "Access-Control-Allow-Origin" | cut -d: -f2- | tr -d ' \r\n')
    test_passed "CORS configured with specific origin: $ALLOWED_ORIGIN"
else
    test_warning "No CORS headers found - may block legitimate cross-origin requests"
fi

###############################################################################
# TEST 14: INFORMATION DISCLOSURE - API ENDPOINTS
###############################################################################

run_test "Information Disclosure - Endpoint Enumeration"

# Test various endpoints for information leakage
ENDPOINTS=(
    "/api/csrf-token"
    "/api/promo-status"
    "/api/stripe/webhook"
    "/.env"
    "/api/config"
    "/api/debug"
)

for endpoint in "${ENDPOINTS[@]}"; do
    RESPONSE=$(curl -s -w "\n%{http_code}" "$APP_URL$endpoint" 2>&1)
    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
    RESPONSE_BODY=$(echo "$RESPONSE" | head -n-1)

    case "$endpoint" in
        "/.env"|"/api/config"|"/api/debug")
            if [ "$HTTP_CODE" = "404" ] || [ "$HTTP_CODE" = "403" ]; then
                test_passed "$endpoint correctly blocked ($HTTP_CODE)"
            else
                test_failed "$endpoint accessible ($HTTP_CODE) - may leak sensitive info"
                echo "Response: $RESPONSE_BODY" >> "$RESULTS_FILE"
            fi
            ;;
        *)
            echo "  $endpoint: HTTP $HTTP_CODE" >> "$RESULTS_FILE"
            ;;
    esac
done

###############################################################################
# SUMMARY
###############################################################################

echo "" | tee -a "$RESULTS_FILE"
echo "========================================" | tee -a "$RESULTS_FILE"
echo "  PENETRATION TEST COMPLETED" | tee -a "$RESULTS_FILE"
echo "========================================" | tee -a "$RESULTS_FILE"
echo "" | tee -a "$RESULTS_FILE"

# Count results
PASS_COUNT=$(grep -c "✅ PASS" "$RESULTS_FILE" || echo "0")
FAIL_COUNT=$(grep -c "❌ FAIL" "$RESULTS_FILE" || echo "0")
WARN_COUNT=$(grep -c "⚠️  WARNING" "$RESULTS_FILE" || echo "0")

echo "RESULTS SUMMARY:" | tee -a "$RESULTS_FILE"
echo "  ✅ Passed: $PASS_COUNT" | tee -a "$RESULTS_FILE"
echo "  ❌ Failed: $FAIL_COUNT" | tee -a "$RESULTS_FILE"
echo "  ⚠️  Warnings: $WARN_COUNT" | tee -a "$RESULTS_FILE"
echo "" | tee -a "$RESULTS_FILE"

if [ "$FAIL_COUNT" -gt 0 ]; then
    echo -e "${RED}RECOMMENDATION: DO NOT LAUNCH - Critical vulnerabilities found${NC}" | tee -a "$RESULTS_FILE"
    exit 1
elif [ "$WARN_COUNT" -gt 3 ]; then
    echo -e "${YELLOW}RECOMMENDATION: CONDITIONAL LAUNCH - Review warnings${NC}" | tee -a "$RESULTS_FILE"
    exit 2
else
    echo -e "${GREEN}RECOMMENDATION: APPROVED - All critical tests passed${NC}" | tee -a "$RESULTS_FILE"
    exit 0
fi

echo "" | tee -a "$RESULTS_FILE"
echo "Full results saved to: $RESULTS_FILE" | tee -a "$RESULTS_FILE"
echo ""
