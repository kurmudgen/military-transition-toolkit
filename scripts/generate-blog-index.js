import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Parse frontmatter from markdown
function parseFrontmatter(content) {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---/
  const match = content.match(frontmatterRegex)

  if (!match) {
    return {}
  }

  const frontmatterText = match[1]
  const data = {}

  frontmatterText.split('\n').forEach(line => {
    const colonIndex = line.indexOf(':')
    if (colonIndex > -1) {
      const key = line.substring(0, colonIndex).trim()
      let value = line.substring(colonIndex + 1).trim()
      // Remove quotes
      value = value.replace(/^["']|["']$/g, '')
      data[key] = value
    }
  })

  return data
}

// Extract excerpt from markdown content (first paragraph after frontmatter)
function extractExcerpt(content) {
  const withoutFrontmatter = content.replace(/^---\s*\n[\s\S]*?\n---\s*\n/, '')
  const paragraphs = withoutFrontmatter
    .split('\n\n')
    .filter(p => p.trim() && !p.startsWith('#'))
    .map(p => p.replace(/\*\*/g, '').trim())

  return paragraphs[0] || ''
}

// Determine category and branch from frontmatter/content
function determineMetadata(frontmatter, content, filename) {
  let category = frontmatter.category || 'Guides'
  let branch = frontmatter.branch || null

  // Try to determine branch from filename/content
  if (!branch) {
    if (filename.match(/^11[a-z]/i) || filename.match(/^12[a-z]/i) || filename.match(/^13[a-z]/i) ||
        filename.match(/^25[a-z]/i) || filename.match(/^68[a-z]/i) || filename.match(/^88[a-z]/i)) {
      branch = 'Army'
    } else if (filename.match(/^0[0-9]{3}/)) {
      branch = 'Marines'
    } else if (filename.match(/^[a-z]{2}-/i) && !filename.includes('best-cities')) {
      if (content.toLowerCase().includes('navy ') || content.toLowerCase().includes('rating')) {
        branch = 'Navy'
      } else if (content.toLowerCase().includes('coast guard')) {
        branch = 'Coast Guard'
      }
    } else if (filename.match(/afsc|^[0-9][a-z][0-9x]+/i)) {
      branch = 'Air Force'
    }
  }

  // Determine category from content if not specified
  if (!frontmatter.category) {
    if (filename.includes('civilian-career-guide') || filename.includes('career-transition')) {
      category = 'Career Guides'
    } else if (filename.includes('best-cities') || filename.includes('veteran-benefits') || filename.includes('state-benefits')) {
      category = 'State Benefits'
    } else if (filename.includes('va-rating') || filename.includes('cp-exam') || filename.includes('disability')) {
      category = 'VA Disability'
    } else if (filename.includes('how-to')) {
      category = 'How-To Guides'
    }
  }

  return { category, branch }
}

console.log('ðŸ” Scanning blog posts...\n')

const blogDir = path.join(__dirname, '../src/content/blog')
const files = fs.readdirSync(blogDir).filter(f => f.endsWith('.md'))

console.log(`Found ${files.length} markdown files\n`)

const posts = []
const errors = []

files.forEach(filename => {
  try {
    const filepath = path.join(blogDir, filename)
    const content = fs.readFileSync(filepath, 'utf8')
    const frontmatter = parseFrontmatter(content)

    // Use publishDate as fallback if date is empty
    const postDate = frontmatter.date || frontmatter.publishDate

    if (!frontmatter.title || !postDate) {
      errors.push(`âš ï¸  ${filename}: Missing title or date in frontmatter`)
      return
    }

    const slug = filename.replace('.md', '')
    const excerpt = frontmatter.excerpt || extractExcerpt(content)
    const { category, branch } = determineMetadata(frontmatter, content, filename)

    const post = {
      slug,
      title: frontmatter.title,
      date: postDate,
      description: frontmatter.description || excerpt,
      keywords: frontmatter.keywords || '',
      excerpt: excerpt.substring(0, 200) + (excerpt.length > 200 ? '...' : ''),
      category
    }

    if (branch) {
      post.branch = branch
    }

    posts.push(post)
  } catch (error) {
    errors.push(`âŒ ${filename}: ${error.message}`)
  }
})

// Sort by date, newest first
posts.sort((a, b) => new Date(b.date) - new Date(a.date))

console.log(`âœ… Successfully processed ${posts.length} posts`)
if (errors.length > 0) {
  console.log(`\nâš ï¸  ${errors.length} errors:\n`)
  errors.forEach(err => console.log(err))
}

// Generate the blog.js file content
const blogJsContent = `// AUTO-GENERATED by scripts/generate-blog-index.js
// Do not edit manually - run 'npm run generate-blog-index' to regenerate

// Custom frontmatter parser (gray-matter doesn't work in browser - no Buffer API)
function parseFrontmatter(content) {
  const frontmatterRegex = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/;
  const match = content.match(frontmatterRegex);

  if (!match) {
    return { data: {}, content: content };
  }

  const frontmatterText = match[1];
  const contentWithoutFrontmatter = match[2];

  // Parse YAML-style frontmatter
  const data = {};
  frontmatterText.split('\\n').forEach(line => {
    const colonIndex = line.indexOf(':');
    if (colonIndex > -1) {
      const key = line.substring(0, colonIndex).trim();
      let value = line.substring(colonIndex + 1).trim();
      // Remove quotes if present
      value = value.replace(/^["']|["']$/g, '');
      data[key] = value;
    }
  });

  return { data, content: contentWithoutFrontmatter };
}

const blogPosts = ${JSON.stringify(posts, null, 2)}

export function getAllPosts() {
  // Get current date at midnight (to include today's posts)
  const today = new Date()
  today.setHours(0, 0, 0, 0)

  // Filter out future posts and sort by date, newest first
  return blogPosts
    .filter(post => new Date(post.date) <= today)
    .sort((a, b) => new Date(b.date) - new Date(a.date))
}

export function getPostBySlug(slug) {
  // Get current date at midnight
  const today = new Date()
  today.setHours(0, 0, 0, 0)

  // Find post and check if it's published (not a future date)
  const post = blogPosts.find(post => post.slug === slug)
  if (!post) return null

  // Return null for future posts (treat as not found)
  if (new Date(post.date) > today) return null

  return post
}

// Function to load markdown content
export async function getPostContent(slug) {
  try {
    // Use dynamic import to load markdown file
    // Path is relative to src/utils/ so ../content/blog/ goes to src/content/blog/
    const module = await import(\`../content/blog/\${slug}.md?raw\`)
    const content = module.default

    // Parse frontmatter using custom parser (gray-matter doesn't work in browser)
    const { data, content: markdown } = parseFrontmatter(content)
    return {
      frontmatter: data,
      content: markdown
    }
  } catch (error) {
    console.error(\`Error loading post \${slug}:\`, error)
    console.error('Attempted path:', \`../content/blog/\${slug}.md?raw\`)
    return null
  }
}
`

const outputPath = path.join(__dirname, '../src/utils/blog.js')
fs.writeFileSync(outputPath, blogJsContent, 'utf8')

console.log(`\nâœ… Generated blog index at ${outputPath}`)
console.log(`ðŸ“ Total posts: ${posts.length}`)
console.log(`ðŸ“… Date range: ${posts[posts.length - 1]?.date} to ${posts[0]?.date}`)

// Show breakdown by category
const byCategory = {}
posts.forEach(post => {
  byCategory[post.category] = (byCategory[post.category] || 0) + 1
})
console.log('\nðŸ“Š Posts by category:')
Object.entries(byCategory).sort((a, b) => b[1] - a[1]).forEach(([cat, count]) => {
  console.log(`   ${cat}: ${count}`)
})

// Show posts scheduled for future
const futurePublish = posts.filter(p => new Date(p.date) > new Date())
if (futurePublish.length > 0) {
  console.log(`\nðŸ“… ${futurePublish.length} posts scheduled for future publication:`)
  futurePublish.slice(0, 10).forEach(p => {
    console.log(`   ${p.date}: ${p.title.substring(0, 60)}...`)
  })
  if (futurePublish.length > 10) {
    console.log(`   ... and ${futurePublish.length - 10} more`)
  }
}

console.log('\nâœ¨ Done! Run your dev server to see all posts on the blog.')
